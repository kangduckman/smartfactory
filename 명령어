
nginx 인증서

step ca certificate \
  nginx-server \
  /home/ubuntu/certs/mtls_nginx.crt /home/ubuntu/certs/mtls_nginx.key \
  --provisioner "SF.CA" \
  --password-file /home/ubuntu/certs/pw.txt \
  --san 10.1.2.232 \
  --ca-url https://10.1.2.112:443 \
  --root /home/ubuntu/certs/root_ca.crt


디바이스 인증서
step ca certificate \
  washer \
  /home/ubuntu/smartfactory/devices/washer_device/certs/mtls_washer.crt /home/ubuntu/smartfactory/devices/washer_device/certs/mtls_washer.key \
  --provisioner "SF.CA" \
  --password-file pw.txt \
  --ca-url https://10.1.2.112:443 \
  --root /home/ubuntu/smartfactory/devices/washer_device/certs/root_ca.crt

step ca certificate \
  capping \
  /home/ubuntu/smartfactory/devices/capper_device/certs/mtls_capper.crt /home/ubuntu/smartfactory/devices/capper_device/certs/mtls_capper.key \
  --provisioner "SF.CA" \
  --password-file pw.txt \
  --ca-url https://10.1.2.112:443 \
  --root /home/ubuntu/smartfactory/devices/capper_device/certs/root_ca.crt

step ca certificate \
  charger \
  /home/ubuntu/smartfactory/devices/charger_device/certs/mtls_charger.crt /home/ubuntu/smartfactory/devices/charger_device/certs/mtls_charger.key \
  --provisioner "SF.CA" \
  --password-file pw.txt \
  --ca-url https://10.1.2.112:443 \
  --root /home/ubuntu/smartfactory/devices/charger_device/certs/root_ca.crt

step ca certificate \
  labeling \
  /home/ubuntu/smartfactory/devices/labeling_device/certs/mtls_labeling.crt /home/ubuntu/smartfactory/devices/labeling_device/certs/mtls_labeling.key \
  --provisioner "SF.CA" \
  --password-file pw.txt \
  --ca-url https://10.1.2.112:443 \
  --root /home/ubuntu/smartfactory/devices/labeling_device/certs/root_ca.crt

#!/bin/bash

# 기본 변수 설정
DEVICE_NAME="washer"
CERT_DIR="/home/ubuntu/smartfactory/devices/washer_device/certs"
APP_PATH="/home/ubuntu/smartfactory/devices/washer_device/washer.py"
STEP_CA_URL="https://10.1.2.112:443"
ROOT_CA="$CERT_DIR/root_ca.crt"
CRT_FILE="$CERT_DIR/mtls_${DEVICE_NAME}.crt"
KEY_FILE="$CERT_DIR/mtls_${DEVICE_NAME}.key"
PW_FILE="$CERT_DIR/pw.txt"

# 인증서 발급
echo "[🔐] 인증서 요청 중..."
step ca certificate \
  "$DEVICE_NAME" \
  "$CRT_FILE" "$KEY_FILE" \
  --provisioner "SF.CA" \
  --password-file "$PW_FILE" \
  --ca-url "$STEP_CA_URL" \
  --root "$ROOT_CA"

# Flask 앱 실행
echo "[🚀] Flask 앱 실행 중..."
python3 "$APP_PATH"


down

#!/bin/bash

DEVICE_NAME="washer"
CERT_DIR="/home/ubuntu/smartfactory/devices/washer_device/certs"

echo "[🧼] 인증서 삭제 중..."
rm -f "$CERT_DIR/mtls_${DEVICE_NAME}.crt"
rm -f "$CERT_DIR/mtls_${DEVICE_NAME}.key"

step 다운로드
  # 1. CLI-only 바이너리 다운로드
curl -LO https://github.com/smallstep/cli/releases/download/v0.23.3/step_linux_0.23.3_amd64.tar.gz

# 2. 압축 해제
tar -xzf step_linux_0.23.3_amd64.tar.gz

# 3. 바이너리 이동
sudo mv step_0.23.3/bin/step /usr/local/bin/

# 4. 정상 동작 확인
step version

echo '3719' > pw.txt


-----BEGIN CERTIFICATE-----
MIIBsDCCAVagAwIBAgIRAJ7Npus6y8SyGVyBXQPkvRkwCgYIKoZIzj0EAwIwNjEV
MBMGA1UEChMMc21hcnRmYWN0b3J5MR0wGwYDVQQDExRzbWFydGZhY3RvcnkgUm9v
dCBDQTAeFw0yNTA2MDMwMjIzMDVaFw0zNTA2MDEwMjIzMDVaMDYxFTATBgNVBAoT
DHNtYXJ0ZmFjdG9yeTEdMBsGA1UEAxMUc21hcnRmYWN0b3J5IFJvb3QgQ0EwWTAT
BgcqhkjOPQIBBggqhkjOPQMBBwNCAAR0FTQK42y3l+XwfKHS70g0aaYHiHr2vyOG
ZVbFxAgRxqe+QR8gfrXn029SKqPjaNlJ6TCTrmntIkHk5rHrbrYgo0UwQzAOBgNV
HQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBATAdBgNVHQ4EFgQUlYiFn1jk
zkbQZIRJEb4C06qz5a8wCgYIKoZIzj0EAwIDSAAwRQIhAMk8gFOlVuLo2YundZv0
PbSlZpsQYWd41fF2upmq5MldAiB35cvqUEI9XIzbeWnKyIEPfbs+nQ963D6Au8ZZ
md5rfA==
-----END CERTIFICATE-----




step-ca 시작 명령어 sudo step-ca ~/.step/config/ca.json --password-file pw.txt


CREATE TABLE error_logs_sns (
    device_name     VARCHAR(50) NOT NULL,
    line_name       VARCHAR(50) NOT NULL,
    abnormal_count  INT NOT NULL,D
    triggered_at    DATETIME DEFAULT CURRENT_TIMESTAMP
);

sql 접속 명령어
mysql -h iot-db.c5a4e0ooeip0.us-east-2.rds.amazonaws.com -P 3306 -u admin -p

w


INSERT INTO error_logs_sns (device_name, value, timestamp)
VALUES ('washer', 70.5, NOW());










SELECT * FROM device_logs;

SELECT * FROM error_logs_sns;




✅ 1단계: 실행 스크립트 작성
📁 파일 만들기
bash
복사
편집
nano /home/ubuntu/start_capper.sh
✍️ 내용 작성
bash
복사
편집


#!/bin/bash

cd /home/ubuntu/smartfactory/devices/capper_device/certs || exit 1

step ca certificate \
  charger \
  mtls_capper.crt mtls_capper.key \
  --provisioner "SF.CA" \
  --password-file pw.txt \
  --ca-url https://10.1.2.112:443 \
  --root root_ca.crt

if [ $? -eq 0 ]; then
  echo "[✅] 인증서 발급 완료, capper.py 실행 시작"
  cd /home/ubuntu/smartfactory/devices/capper_device || exit 1
  source venv/bin/activate
  python3 capper.py
else
  echo "[❌] 인증서 발급 실패, capper.py 실행 안 함"
fi
🔓 실행 권한 부여
bash
복사
편집
chmod +x /home/ubuntu/start_capper.sh
✅ 2단계: 종료 시 인증서 삭제 스크립트 작성
bash
복사
편집
nano /home/ubuntu/capper-cleanup.sh
✍️ 내용 작성
bash
복사
편집
#!/bin/bash
echo "[🧹] 인증서 삭제 중..."
rm -f /home/ubuntu/smartfactory/devices/capper_device/certs/mtls_capper.*
bash
복사
편집
chmod +x /home/ubuntu/capper-cleanup.sh
✅ 3단계: systemd 서비스 등록
bash
복사
편집
sudo nano /etc/systemd/system/capper.service
✍️ 내용 작성
ini
복사
편집
[Unit]
Description=SmartFactory Capper Device Auto Start
After=network.target

[Service]
User=ubuntu
ExecStart=/home/ubuntu/start_capper.sh
ExecStopPost=/home/ubuntu/capper-cleanup.sh
WorkingDirectory=/home/ubuntu
Restart=on-failure
Environment=PATH=/home/ubuntu/smartfactory/devices/capper_device/venv/bin:/usr/bin
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
✅ 4단계: systemd 적용
bash
복사
편집
sudo systemctl daemon-reexec
sudo systemctl daemon-reload
sudo systemctl enable capper
sudo systemctl start capper
✅ 5단계: 상태 및 로그 확인
서비스 상태 확인
bash
복사
편집
sudo systemctl status capper
실시간 로그 보기
bash
복사
편집
journalctl -u capper -f





import pymysql
import boto3
import json

# RDS 연결 설정
DB_CONFIG = {
    "host": "iot-db.c5a4e0ooeip0.us-east-2.rds.amazonaws.com",
    "user": "admin",
    "password": "welcome1",
    "database": "smart_factory",
    "charset": "utf8mb4",
    "cursorclass": pymysql.cursors.DictCursor
}

# SQS 연결 설정
sqs = boto3.client('sqs', region_name='us-east-2')
QUEUE_URL = "https://sqs.us-east-2.amazonaws.com/207567776727/err_logs_sns_q"

def lambda_handler(event, context):
    print("Lambda 실행됨 - RDS에서 에러 로그 조회 중...")

    try:
        conn = pymysql.connect(**DB_CONFIG)
        with conn.cursor() as cursor:
            # 1. 처리되지 않은 데이터 조회 (예: 최대 50건)
            cursor.execute("SELECT * FROM error_logs_sns LIMIT 50")
            rows = cursor.fetchall()

            if not rows:
                print("처리할 데이터 없음.")
                return {"status": "No data"}

            for row in rows:
                # 2. 메시지 구성
                msg = {
                    "device": row["device_name"],
                    "line": row["line_name"],
                    "value": row["last_abnormal_value"],
                    "count": row["abnormal_count"]
                }

                # 3. SQS로 전송
                sqs.send_message(
                    QueueUrl=QUEUE_URL,
                    MessageBody=json.dumps(msg)
                )
                print(f"[→] SQS 전송됨: {msg}")

                # 4. RDS에서 삭제
                cursor.execute("DELETE FROM error_logs_sns WHERE id = %s", (row["id"],))

            conn.commit()
            print("처리 완료 및 삭제됨.")

        return {"status": "Success", "count": len(rows)}

    except Exception as e:
        print("❌ 에러:", str(e))
        return {"status": "Error", "message": str(e)}

    finally:
        if conn:
            conn.close()


import boto3
import json

sqs = boto3.client('sqs', region_name='us-east-2')
QUEUE_URL = "https://sqs.us-east-2.amazonaws.com/207567776727/err_logs_sns_q"

try:
    msg = {
        "device": "washer",
        "line": "line_1",
        "value": 64.2,
        "count": 6
    }

    res = sqs.send_message(
        QueueUrl=QUEUE_URL,
        MessageBody=json.dumps(msg)
    )

    print("[✅] SQS 전송 성공:", res["MessageId"])
except Exception as e:
    print("[❌] SQS 전송 실패:", str(e))



import pymysql
import boto3
import json

# ✅ RDS 연결 설정
DB_CONFIG = {
    "host": "iot-db.c5a4e0ooeip0.us-east-2.rds.amazonaws.com",
    "user": "admin",
    "password": "welcome1",
    "database": "smart_factory",
    "charset": "utf8mb4",
    "cursorclass": pymysql.cursors.DictCursor,
    "connect_timeout": 5  # 🔒 타임아웃 방지
}

# ✅ SQS 연결 설정
sqs = boto3.client('sqs', region_name='us-east-2')
QUEUE_URL = "https://sqs.us-east-2.amazonaws.com/207567776727/err_logs_sns_q"

def lambda_handler(event, context):
    print("[1] Lambda 시작됨")
    conn = None

    try:
        print("[2] DB 연결 시도")
        conn = pymysql.connect(**DB_CONFIG)
        print("[3] 연결 성공")

        with conn.cursor() as cursor:
            print("[4] 쿼리 실행 시도")
            cursor.execute("""
                SELECT id, device_name, line_name, last_abnormal_value, abnormal_count
                FROM error_logs_sns
                ORDER BY id ASC
                LIMIT 10
            """)
            rows = cursor.fetchall()
            print("[5] 쿼리 실행 완료")

            if not rows:
                print("처리할 데이터 없음.")
                return {"status": "No data"}

            deleted_ids = []

            for row in rows:
                msg = {
                    "device": row["device_name"],
                    "line": row["line_name"],
                    "value": row["last_abnormal_value"],
                    "count": row["abnormal_count"]
                }

                try:
                    sqs.send_message(
                        QueueUrl=QUEUE_URL,
                        MessageBody=json.dumps(msg)
                    )
                    print(f"[→] SQS 전송됨: {msg}")
                    deleted_ids.append(row["id"])
                except Exception as sqs_err:
                    print(f"[X] SQS 전송 실패: {sqs_err} → 해당 항목 삭제 보류")

            # ✅ 전송 성공한 데이터만 삭제
            if deleted_ids:
                format_strings = ','.join(['%s'] * len(deleted_ids))
                cursor.execute(
                    f"DELETE FROM error_logs_sns WHERE id IN ({format_strings})",
                    tuple(deleted_ids)
                )
                print(f"[✓] 삭제된 ID: {deleted_ids}")

            conn.commit()
            print(f"[✓] 최종 커밋 완료 - 처리 건수: {len(deleted_ids)}")
            return {"status": "Success", "count": len(deleted_ids)}

    except Exception as e:
        print("❌ 예외 발생:", str(e))
        return {"status": "Error", "message": str(e)}

    finally:
        if conn:
            conn.close()
            print("[ℹ] DB 연결 종료됨")


step-ca로 발급받은 인증서가 기간 만료되는 문제가 발생했다. 이를 인스턴스가 켜질 때마다 새롭게 인증서를 발급받는 형식으로 새로 구성하였다. 다음번에는 인증서 기간을 관리하는 방법을 배우면 좋을 것 같다는 생각이 든다.